{"version":3,"sources":["webpack:///component---src-pages-hero-js-7cfd1de9034d77343d06.js","webpack:///./src/constants/index.js","webpack:///./src/helpers/waveform.helpers.js","webpack:///./src/images/banner.jpg?8491","webpack:///./src/images/pic01.jpg","webpack:///./src/pages/hero.js","webpack:///./src/utils/index.js"],"names":["webpackJsonp","203","module","exports","__esModule","COLORS","WAVEFORM_ASPECT_RATIO","DEFAULT_WAVEFORM_SHAPE","DEFAULT_WAVEFORM_SIZE","DEFAULT_WAVEFORM_NUM_OF_CYCLES","DEFAULT_WAVEFORM_AMPLITUDE","SHAPES","SPRING_SETTINGS","stiffness","damping","precision","red","100","300","500","700","900","orange","green","indigo","blue","purple","pink","gray","50","400","800","cream","white","primary","secondary","tertiary","BREAKPOINT_SIZES","xs","sm","md","lg","xl","mobileRegex","BREAKPOINTS","xsMin","smMin","mdMin","lgMin","xlMin","desktop","MAX_WIDTH","base","IS_MOBILE_USER_AGENT","test","navigator","userAgent","205","__webpack_require__","_objectWithoutProperties","obj","keys","target","i","indexOf","Object","prototype","hasOwnProperty","call","getWaveforms","getHarmonicsForWave","convertProgressToCycle","applyWaveformAddition","getInterceptPosition","translateAxisRelativeYValue","getPositionAtPointRelativeToAxis","createSVGPathFromWaveformPoints","getPointsForWaveform","undefined","_extends","assign","arguments","length","source","key","_constants","_utils","fixPeaks","_ref","shape","frequency","amplitude","width","_ref$offset","offset","ratioBetweenPointsAndPixels","xValues","range","rawValues","map","x","widthOfSingleCycle","progressRelativeToCycles","progress","y","values","forEach","value","index","previousVal","nextVal","Math","abs","previousPreviousVal","slope","points","height","reduce","acc","_ref2","cycleLength","PI","totalLength","progressThroughDrawableArea","positionInRads","sin","progressThroughIteration","adjustedMax","quadrant","floor","progressThroughQuadrant","Error","yValue","incrementedYValue","relativePosition","mainWave","appliedWaves","ratio","point","appliedWavesAtPoint","sum","wave","mainValue","appliedValue","_ref3","_ref3$harmonicsForSha","harmonicsForShape","baseFrequency","baseAmplitude","maxNumberToGenerate","delegated","harmonicIndex","isOddHarmonic","amplitudePhaseMultiplier","_ref4","type","_ref4$phase","phase","numOfHarmonics","strokeWidth","color","convertHexToRGBA","sharedProperties","concat","125","p","126","208","_interopRequireDefault","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_react","_react2","_waveform","_banner","_banner2","_pic","Animation","_React$Component","this","_this","state","componentDidMount","_this2","animate","updateProgress","window","requestAnimationFrame","setState","previousState","props","speed","render","opacity","strokeLinecap","relativeY","svgPath","createElement","style","overflow","id","d","stroke","fill","clipPath","React","Component","defaultProps","src","bannerImageSource","212","requestAnimationFramePromise","Promise","resolve","setTimeoutPromise","duration","setTimeout","start","end","step","typeofStart","typeofEnd","push","charCodeAt","String","fromCharCode","sample","arr","random","min","max","mean","clamp","val","roundTo","number","places","round","pow","debounce","callback","wait","timeoutId","_len","args","Array","_key","clearTimeout","apply","isEmpty","omit","newObj","name","convertArrayToMap","list","item","_extends2","toggleInArray","includes","filter","mergeUnique","arr1","arr2","findRight","predicate","slice","reverse","find","deleteCookie","document","cookie","encodeURIComponent","hex","alpha","r","parseInt","g","b"],"mappings":"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","file":"component---src-pages-hero-js-7cfd1de9034d77343d06.js","sourcesContent":["webpackJsonp([46383895804194],{\n\n/***/ 203:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t// Logic\n\tvar WAVEFORM_ASPECT_RATIO = exports.WAVEFORM_ASPECT_RATIO = 1;\n\tvar DEFAULT_WAVEFORM_SHAPE = exports.DEFAULT_WAVEFORM_SHAPE = 'sine';\n\tvar DEFAULT_WAVEFORM_SIZE = exports.DEFAULT_WAVEFORM_SIZE = 200;\n\tvar DEFAULT_WAVEFORM_NUM_OF_CYCLES = exports.DEFAULT_WAVEFORM_NUM_OF_CYCLES = 1;\n\tvar DEFAULT_WAVEFORM_AMPLITUDE = exports.DEFAULT_WAVEFORM_AMPLITUDE = 1;\n\t\n\tvar SHAPES = exports.SHAPES = ['sine', 'triangle', 'square', 'sawtooth'];\n\t\n\tvar SPRING_SETTINGS = exports.SPRING_SETTINGS = {\n\t  stiffness: 170,\n\t  damping: 26,\n\t  precision: 0.1\n\t};\n\t\n\tvar COLORS = exports.COLORS = {\n\t  red: {\n\t    '100': '#FFCDD2',\n\t    '300': '#E57373',\n\t    '500': '#F44336',\n\t    '700': '#D32F2F',\n\t    '900': '#B71C1C'\n\t  },\n\t  orange: {\n\t    '100': '#FFECB3',\n\t    '300': '#FFD54F',\n\t    '500': '#FFC107',\n\t    '700': '#FFA000',\n\t    '900': '#ee7314'\n\t  },\n\t  green: {\n\t    '100': '#DCEDC8',\n\t    '300': '#AED581',\n\t    '500': '#8BC34A',\n\t    '700': '#689F38',\n\t    '900': '#33691E'\n\t  },\n\t  indigo: {\n\t    '100': '#b3defc',\n\t    '300': '#4f9ef7',\n\t    '500': '#0380f4',\n\t    '700': '#0268d1',\n\t    '900': '#01499b'\n\t  },\n\t  blue: {\n\t    '100': '#B3E5FC',\n\t    '300': '#4FC3F7',\n\t    '500': '#03A9F4',\n\t    '700': '#0288D1',\n\t    '900': '#01579B'\n\t  },\n\t  purple: {\n\t    '100': '#E1BEE7',\n\t    '300': '#BA68C8',\n\t    '500': '#9C27B0',\n\t    '700': '#7B1FA2',\n\t    '900': '#4A148C'\n\t  },\n\t  pink: {\n\t    '100': '#F8BBD0',\n\t    '300': '#F06292',\n\t    '500': '#E91E63',\n\t    '700': '#C2185B',\n\t    '900': '#880E4F'\n\t  },\n\t  gray: {\n\t    '50': '#FAFAFA',\n\t    '100': '#F5F5F5',\n\t    '300': '#E0E0E0',\n\t    '400': '#CCCCCC',\n\t    '500': '#9E9E9E',\n\t    '700': '#616161',\n\t    '800': '#414141',\n\t    '900': '#212121'\n\t  },\n\t  cream: {\n\t    '50': '#FFFEFC'\n\t  },\n\t  white: '#FFFFFF'\n\t};\n\t\n\tCOLORS.primary = COLORS.indigo;\n\tCOLORS.secondary = COLORS.pink;\n\tCOLORS.tertiary = COLORS.orange;\n\t\n\t// Media queries\n\tvar BREAKPOINT_SIZES = exports.BREAKPOINT_SIZES = {\n\t  xs: 320,\n\t  sm: 540,\n\t  md: 900,\n\t  lg: 1100,\n\t  xl: 1440\n\t};\n\t\n\tvar BREAKPOINTS = exports.BREAKPOINTS = {\n\t  xs: '(max-width: ' + BREAKPOINT_SIZES.xs + 'px)',\n\t  sm: '(max-width: ' + BREAKPOINT_SIZES.sm + 'px)',\n\t  md: '(max-width: ' + BREAKPOINT_SIZES.md + 'px)',\n\t  lg: '(max-width: ' + BREAKPOINT_SIZES.lg + 'px)',\n\t  xl: '(max-width: ' + BREAKPOINT_SIZES.xl + 'px)',\n\t  xsMin: '(min-width: ' + BREAKPOINT_SIZES.xs + 'px)',\n\t  smMin: '(min-width: ' + BREAKPOINT_SIZES.sm + 'px)',\n\t  mdMin: '(min-width: ' + BREAKPOINT_SIZES.md + 'px)',\n\t  lgMin: '(min-width: ' + BREAKPOINT_SIZES.lg + 'px)',\n\t  xlMin: '(min-width: ' + BREAKPOINT_SIZES.xl + 'px)',\n\t  desktop: '(min-width: ' + (BREAKPOINT_SIZES.sm + 1) + 'px)'\n\t};\n\t\n\tvar MAX_WIDTH = exports.MAX_WIDTH = {\n\t  sm: '100%',\n\t  md: BREAKPOINT_SIZES.md + 'px',\n\t  base: BREAKPOINT_SIZES.lg + 'px'\n\t};\n\t\n\tvar mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i;\n\tvar IS_MOBILE_USER_AGENT = exports.IS_MOBILE_USER_AGENT = mobileRegex.test(navigator.userAgent);\n\n/***/ }),\n\n/***/ 205:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.getWaveforms = exports.getHarmonicsForWave = exports.convertProgressToCycle = exports.applyWaveformAddition = exports.getInterceptPosition = exports.translateAxisRelativeYValue = exports.getPositionAtPointRelativeToAxis = exports.createSVGPathFromWaveformPoints = exports.getPointsForWaveform = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _constants = __webpack_require__(203);\n\t\n\tvar _utils = __webpack_require__(212);\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\t/**\n\t * This method gets an array of axis-relative points that can be used for\n\t * further calculations.\n\t * Given a waveform shape, and some information about its frequency/offset/size,\n\t * this method returns an array of X/Y values that describes the waveform.\n\t * This is NOT plot-ready, since the Y values range from -1 to 1.\n\t * Further processing is required to get something drawable.\n\t */\n\tvar getPointsForWaveform = exports.getPointsForWaveform = function getPointsForWaveform(_ref) {\n\t  var shape = _ref.shape,\n\t      frequency = _ref.frequency,\n\t      amplitude = _ref.amplitude,\n\t      width = _ref.width,\n\t      _ref$offset = _ref.offset,\n\t      offset = _ref$offset === undefined ? 0 : _ref$offset;\n\t\n\t  // Get an array of `x` values.\n\t  // For now, we're drawing lines at every second point, for performance.\n\t  // After experimentation, this may change.\n\t  var ratioBetweenPointsAndPixels = 2;\n\t  var xValues = (0, _utils.range)(0, width + 1, ratioBetweenPointsAndPixels);\n\t  // Convert each X value to a proper coordinate system, relative to the axis\n\t  // (so, Y values will be from -1 to 1)\n\t  var rawValues = xValues.map(function (x) {\n\t    // We need a progress value, to help inform where this `x` value is, in\n\t    // terms of the cycles drawn.\n\t\n\t    // Start by getting the width of a single cycle.\n\t    // If `frequency` is `1`, then this is just the whole width.\n\t    // If we're drawing more/less than a single cycle, though, we need to do\n\t    // some division.\n\t    var widthOfSingleCycle = width / frequency;\n\t\n\t    // Next, we need to figure out the progress in terms of the cycle.\n\t    // If the frequency is 4, This progress will be a value from 0 to 4.\n\t    var progressRelativeToCycles = x / widthOfSingleCycle;\n\t\n\t    // Finally, we have to take the waveform's offset into account.\n\t    // As a refresher: `offset` ranges from 0 to 99, and it controls how much\n\t    // to shift the waveform by.\n\t    // Example: A sine wave with 50 offset will look like an inverted sine wave.\n\t    // The `* 100` is necessary since offset is 0-99 instead of 0-1.\n\t    // TODO: Probably makes sense to keep it from 0-1, makes more semantic sense\n\t    var progress = progressRelativeToCycles * 100 + offset;\n\t    return {\n\t      x: x,\n\t      y: getPositionAtPointRelativeToAxis(shape, frequency, amplitude, progress)\n\t    };\n\t  });\n\t\n\t  if (shape === 'triangle') {\n\t    // Find the peak points in the wave, and set it to max amplitude.\n\t    fixPeaks(amplitude, rawValues);\n\t  }\n\t\n\t  return rawValues;\n\t};\n\t\n\t// HACK HACK HACK: So, the current method I have for generating waveforms is\n\t// flawed, in that it produces glitchy peaks because of rounding errors.\n\t// The proper solution eludes me, but I did find this mathy way of fixing it.\n\t// I'll go through and find those 'peak' values, and adjust their coordinates to\n\t// actually sit at the peak.\n\tvar fixPeaks = function fixPeaks(amplitude, values) {\n\t  return values.forEach(function (value, index) {\n\t    if (index <= 2 || index === values.length - 1) {\n\t      return;\n\t    }\n\t\n\t    var previousVal = values[index - 1];\n\t    var nextVal = values[index + 1];\n\t\n\t    if (Math.abs(value.y) > Math.abs(previousVal.y) && Math.abs(value.y) > Math.abs(nextVal.y)) {\n\t      // Is a peak!\n\t      // Figure out the slope of the line.\n\t      var previousPreviousVal = values[index - 2];\n\t\n\t      var slope = (previousVal.y - previousPreviousVal.y) / (previousVal.x - previousPreviousVal.x);\n\t\n\t      value.y = value.y < 0 ? -amplitude : amplitude;\n\t\n\t      value.x = (value.y - previousVal.y) / slope + previousVal.x;\n\t    }\n\t  });\n\t};\n\t\n\tvar createSVGPathFromWaveformPoints = exports.createSVGPathFromWaveformPoints = function createSVGPathFromWaveformPoints(points, height) {\n\t  return points.reduce(function (acc, _ref2, index) {\n\t    var x = _ref2.x,\n\t        y = _ref2.y;\n\t\n\t    // For the very first point, we have to Move to that area\n\t    if (index === 0) {\n\t      return 'M ' + x + ',' + y + ' ';\n\t    }\n\t\n\t    // For all subsequent points, we can just draw a line to it.\n\t    return acc + ' L ' + x + ',' + y;\n\t  }, '');\n\t};\n\t/**\n\t * Given progress between 0 and 100, figure out the Y position, relative\n\t * to the X axis (from 1 to -1)\n\t */\n\tvar getPositionAtPointRelativeToAxis = exports.getPositionAtPointRelativeToAxis = function getPositionAtPointRelativeToAxis(shape, frequency, amplitude, progress) {\n\t  switch (shape) {\n\t    case 'sine':\n\t      {\n\t        // Each sine cycle is 2Pi long, in trigonometry terms.\n\t        // The frequency determines how many cycles are in the available space.\n\t        var cycleLength = Math.PI * 2;\n\t        var totalLength = cycleLength * frequency;\n\t\n\t        // the progress is through the given cycle, but we may be rendering\n\t        // multiple cycles.\n\t        var progressThroughDrawableArea = progress * (1 / frequency);\n\t\n\t        // Right now, `progress` ranges from 0 to 100.\n\t        // Normalize this value to fit between 0 and `totalLength`.\n\t        // Just cross-multiplying to get the normalized value:\n\t        //\n\t        // progress         positionInRads\n\t        // --------  =      --------------\n\t        //   100             totalLength\n\t        //\n\t        // prettier-ignore\n\t        var positionInRads = progressThroughDrawableArea * totalLength / 100;\n\t\n\t        // Now we can simply take the sin of the rad position to get a value,\n\t        // from -1 to 1. We multiply by amplitude (a value between 0 and 1) to\n\t        // make sure the waveform isn't more powerful than desired.\n\t        return Math.sin(positionInRads) * amplitude;\n\t      }\n\t\n\t    case 'square':\n\t      {\n\t        // Square waves are easy; the value is either `amplitude` or `-amplitude`.\n\t        // Figure out how far we are through the current iteration, since the\n\t        // drawable wave might have multiple iterations if frequency > 1Hz.\n\t        var progressThroughIteration = progress % 100;\n\t\n\t        return progressThroughIteration < 50 ? amplitude : -amplitude;\n\t      }\n\t\n\t    case 'sawtooth':\n\t      {\n\t        // Each sawtooth iteration simply ranges from `-amplitude` to `amplitude`\n\t        // in a linear way.\n\t\n\t        var _progressThroughIteration = progress % 100;\n\t\n\t        // Normally, this would be a simple cross-multiplication to normalize\n\t        // between min and max, but our min is a negative number. Start by\n\t        // adding that amount so that it ranges from `0 - 2*amplitude`\n\t        var adjustedMax = amplitude * 2;\n\t\n\t        return _progressThroughIteration * adjustedMax / 100 - amplitude;\n\t      }\n\t\n\t    case 'triangle':\n\t      {\n\t        // This waveform might include multiple iterations, if frequency > 1Hz.\n\t        // This is an easy thing to solve, though; make it cyclical so that we're\n\t        // only looking at values from 0 to 99.\n\t        var _progressThroughIteration2 = progress % 100;\n\t\n\t        // Each triangle iteration has 4 quadrants of equal size:\n\t        // - the initial ramp up from 0 to 1\n\t        // - the ramp down from 1 to 0,\n\t        // - another from 0 to -1\n\t        // - the final ramp back up from -1 to 0.\n\t        //\n\t        //  Q1 | Q2 |    |\n\t        //    /|\\   |    |\n\t        //  /  |  \\ |    |\n\t        //  ---|---\\|--- |-----/--------------------------------\n\t        //     |    | \\  |   /\n\t        //     |    |  \\ | /\n\t        //     |    | Q3 | Q4\n\t        //\n\t        // Our `progressThroughIteration` is a value from 0 to 99, so we can\n\t        // figure out which quadrant it's in by dividing this number by 4.\n\t        //\n\t        // (Adding 1 so that it ranges from 1-4 instead of 0.3. So that, for\n\t        // example, 'second quadrant' is unambiguous.)\n\t        var quadrant = Math.floor(_progressThroughIteration2 / 25) + 1;\n\t\n\t        var progressThroughQuadrant = progress % 25;\n\t\n\t        switch (quadrant) {\n\t          case 1:\n\t            {\n\t              // Quadrant 1 is easy, since it ranges from 0 to 1.\n\t              // To get the value from 0 to 1, just divide progress by the\n\t              // quadrant max (25). Then, to get the amplitude, multiply by the\n\t              // wave's actual amplitude.\n\t              //\n\t              // To understand the `* amplitude` bit, remember that the wave's\n\t              // amplitude ranges from 0 to 1.\n\t              // If the wave is at max loudness, this value wouldn't be necessary\n\t              // (since `* 1` can always be omitted).\n\t              // If the wave is at half amplitude, though, our triangle's peak\n\t              // should be halfway up from the X-axis. So we multiply by 0.5.\n\t              return progressThroughQuadrant / 25 * amplitude;\n\t            }\n\t\n\t          case 2:\n\t            {\n\t              // Quadrant 2 is similar to quadrant 1, but reversed. Going from 1-0.\n\t              // To solve this, we can simply subtract the value from our max\n\t              // amplitude.\n\t              // Again, if we're at max amplitude, this would just be `1 - stuff`.\n\t              // Since we want to \"invert\" it vertically:\n\t              //\n\t              // Value  |  Inverted value\n\t              // 1      |  0\n\t              // 0.25   |  0.75\n\t              // 0.5    |  0.5\n\t              //\n\t              // See how you can \"invert\" each value by subtracting it from 1?\n\t              //\n\t              // But yeah, because our max amplitude can be less than 1, we have\n\t              // to use `amplitude` instead of `1`.\n\t              return amplitude - progressThroughQuadrant / 25 * amplitude;\n\t            }\n\t\n\t          case 3:\n\t            {\n\t              // Our third quadrant ranges from 0 to -1.\n\t              // This is getting more complicated, but it's really just building on\n\t              // the previous 2 quadrants.\n\t              //\n\t              // Quadrant 3 is identical to quadrant 2 except that it's lower.\n\t              // If amplitude is 1, you could think of quadrant 2 as being 1 lower\n\t              // than quadrant 3.\n\t              //\n\t              // By subtracting our max amplitude from the end of the Q2 formula,\n\t              // we lower it accordingly.\n\t              return amplitude - progressThroughQuadrant / 25 * amplitude - amplitude;\n\t            }\n\t\n\t          case 4:\n\t            {\n\t              // Finally, our final quadrant ranges from -1 to 0.\n\t              // Similar to how Q3 was just Q2 minus amplitude, Q4 is really just\n\t              // Q1 minus amplitude.\n\t              //\n\t              // This make sense when you think about it. Q3 is just Q2 but lower.\n\t              // Similarly, Q4 is just Q1 but lower.\n\t              return progressThroughQuadrant / 25 * amplitude - amplitude;\n\t            }\n\t\n\t          default:\n\t            {\n\t              // Should be impossible\n\t              throw new Error('Unrecognized quadrant!');\n\t            }\n\t        }\n\t      }\n\t\n\t    default:\n\t      throw new Error('Unrecognized waveform shape supplied: ' + shape);\n\t  }\n\t};\n\t\n\tvar translateAxisRelativeYValue = exports.translateAxisRelativeYValue = function translateAxisRelativeYValue(\n\t// a value from -1 to 1 (relative to the axis)\n\tyValue,\n\t// The height in pixels of our waveform drawing\n\theight) {\n\t  // Invert the y value. This is so that negative values are below the line,\n\t  // while positive ones are above it.\n\t  yValue *= -1;\n\t\n\t  // Start by changing the range of the yValue:\n\t  // -1...1 -> 0...2\n\t  var incrementedYValue = yValue + 1;\n\t\n\t  // Now we can just cross-multiply!\n\t  //     Y              X\n\t  //  ------    =    ------\n\t  //     2           height\n\t  //\n\t  // prettier-ignore\n\t  return incrementedYValue * height / 2;\n\t};\n\t\n\tvar getInterceptPosition = exports.getInterceptPosition = function getInterceptPosition(shape, height, frequency, amplitude, progress) {\n\t  var relativePosition = getPositionAtPointRelativeToAxis(shape, frequency, amplitude, progress);\n\t\n\t  return translateAxisRelativeYValue(relativePosition, height);\n\t};\n\t\n\tvar applyWaveformAddition = exports.applyWaveformAddition = function applyWaveformAddition(mainWave, appliedWaves,\n\t// ratio is the \"effect\" of the applied wave on the main wave, from 0-1.\n\tratio) {\n\t  if (ratio === 0) {\n\t    // At 0, it has no effect. We can just return the main wave as-is.\n\t    return mainWave;\n\t  }\n\t\n\t  // For everything in-between, the applied wave adjusts the main wave by the\n\t  // amount specified.\n\t  return mainWave.map(function (point, index) {\n\t    var appliedWavesAtPoint = (0, _utils.sum)(appliedWaves.map(function (wave) {\n\t      return wave[index].y;\n\t    }));\n\t\n\t    var mainValue = point.y * (1 - ratio);\n\t    var appliedValue = appliedWavesAtPoint * ratio;\n\t\n\t    return {\n\t      x: point.x,\n\t      y: mainValue + appliedValue\n\t    };\n\t  });\n\t};\n\t\n\tvar convertProgressToCycle = exports.convertProgressToCycle = function convertProgressToCycle(progress) {\n\t  return progress * 100 % 100;\n\t};\n\t\n\tvar getHarmonicsForWave = function getHarmonicsForWave(_ref3) {\n\t  var _ref3$harmonicsForSha = _ref3.harmonicsForShape,\n\t      harmonicsForShape = _ref3$harmonicsForSha === undefined ? 'sine' : _ref3$harmonicsForSha,\n\t      baseFrequency = _ref3.baseFrequency,\n\t      baseAmplitude = _ref3.baseAmplitude,\n\t      maxNumberToGenerate = _ref3.maxNumberToGenerate,\n\t      delegated = _objectWithoutProperties(_ref3, ['harmonicsForShape', 'baseFrequency', 'baseAmplitude', 'maxNumberToGenerate']);\n\t\n\t  if (maxNumberToGenerate === 0) {\n\t    return [];\n\t  }\n\t\n\t  switch (harmonicsForShape) {\n\t    // Sine waves have no harmonics\n\t    case 'sine':\n\t      return [];\n\t\n\t    case 'sawtooth':\n\t      {\n\t        return (0, _utils.range)(1, maxNumberToGenerate).map(function (i) {\n\t          // the first index would be our main wave; we're only interested in the\n\t          // harmonics.\n\t          var harmonicIndex = i + 1;\n\t\n\t          var frequency = baseFrequency * harmonicIndex;\n\t          var amplitude = baseAmplitude / harmonicIndex;\n\t\n\t          return _extends({ shape: 'sine', frequency: frequency, amplitude: amplitude }, delegated);\n\t        });\n\t      }\n\t\n\t    case 'square':\n\t      {\n\t        return (0, _utils.range)(1, maxNumberToGenerate).map(function (i) {\n\t          // Our index will be simple increments (1,2,3,4...)\n\t          // We're only interested in ODD harmonics for square waves, though\n\t          // (3, 5, 7, 9...)\n\t          //\n\t          // We want to do the following conversion:\n\t          //\n\t          // Index | Harmonic\n\t          //   1   |    3\n\t          //   2   |    5\n\t          //   3   |    7\n\t          //   4   |    9\n\t          //\n\t          // Looking at the numbers, a simple formula presents itself:\n\t          var harmonicIndex = i * 2 + 1;\n\t\n\t          var frequency = baseFrequency * harmonicIndex;\n\t          var amplitude = baseAmplitude / harmonicIndex;\n\t\n\t          return _extends({ shape: 'sine', frequency: frequency, amplitude: amplitude }, delegated);\n\t        });\n\t      }\n\t\n\t    case 'triangle':\n\t      {\n\t        // Triangles are similar to squares - they feature odd harmonics at\n\t        // ever-increasing amplitudes - but with one wrinkle: the phase is\n\t        // inverted for every second harmonic.\n\t        return (0, _utils.range)(1, maxNumberToGenerate).map(function (i) {\n\t          var harmonicIndex = i * 2 + 1;\n\t\n\t          // Triangles alternate phases.\n\t          // To understand this, first we need to understand that these two things\n\t          // are equivalent:\n\t          //\n\t          // - cut the offset of the waveform by π (AKA 50%)\n\t          // - Multiplying the amplitude by -1\n\t          //\n\t          // The reason for this makes sense if you imagine both scenarios.\n\t          // A periodic waveform like the triangle can be thought of in 2 \"halves\"\n\t          // the first half is a positive triangle, the second half is negative.\n\t          //\n\t          //   First\n\t          //    /\\ |\n\t          //  /   \\|\n\t          //  -----|------/-\n\t          //       |\\   /\n\t          //       | \\/\n\t          //       |Second\n\t          //\n\t          // When we rotate the offset by 50%, we invert it:\n\t          //\n\t          //           Second\n\t          //             /\\\n\t          //           /   \\\n\t          //  \\------/------\\\n\t          //   \\   /\n\t          //    \\/\n\t          //  First\n\t          //\n\t          // Similarly, if we multiply every point's amplitude by -1, we achieve\n\t          // the exact same effect, through a different mechanism; instead of\n\t          // pulling the waveform forward by 50%, we rotate it across a 3D axis\n\t          // (imagine flipping a sign away from you to be upside down).\n\t          //\n\t          // So yeah, for triangles to work, we need to invert every second\n\t          // wave that we add.\n\t          var isOddHarmonic = i % 2 !== 0;\n\t          var amplitudePhaseMultiplier = isOddHarmonic ? -1 : 1;\n\t\n\t          var frequency = baseFrequency * harmonicIndex;\n\t          var amplitude = baseAmplitude / Math.pow(harmonicIndex, 2) * amplitudePhaseMultiplier;\n\t\n\t          return _extends({ shape: 'sine', frequency: frequency, amplitude: amplitude }, delegated);\n\t        });\n\t      }\n\t\n\t    default:\n\t      return [];\n\t  }\n\t};\n\t\n\texports.getHarmonicsForWave = getHarmonicsForWave;\n\tvar getWaveforms = exports.getWaveforms = function getWaveforms(_ref4) {\n\t  var type = _ref4.type,\n\t      harmonicsForShape = _ref4.harmonicsForShape,\n\t      _ref4$phase = _ref4.phase,\n\t      phase = _ref4$phase === undefined ? 0 : _ref4$phase,\n\t      baseFrequency = _ref4.baseFrequency,\n\t      baseAmplitude = _ref4.baseAmplitude,\n\t      numOfHarmonics = _ref4.numOfHarmonics;\n\t\n\t  switch (type) {\n\t    case 'phase':\n\t      {\n\t        // Our phase ranges from 0 to 360, but we need to convert that to our\n\t        // 0-100 offset for the waves. Additionally, we want the value to go\n\t        // from 100-o, so that the phase moves to the right instead of the left.\n\t        var offset = 100 - phase * 100 / 360;\n\t\n\t        return [{\n\t          shape: 'sine',\n\t          frequency: baseFrequency,\n\t          amplitude: baseAmplitude * 0.5,\n\t          offset: offset,\n\t          strokeWidth: 5,\n\t          color: (0, _utils.convertHexToRGBA)(_constants.COLORS.secondary[500], 0.6)\n\t        }, {\n\t          shape: 'sine',\n\t          frequency: baseFrequency,\n\t          amplitude: baseAmplitude * 0.5,\n\t          offset: 0,\n\t          strokeWidth: 5,\n\t          color: (0, _utils.convertHexToRGBA)(_constants.COLORS.primary[500], 0.6)\n\t        }];\n\t      }\n\t\n\t    case 'chord':\n\t      {\n\t        var sharedProperties = {\n\t          shape: 'sine',\n\t          amplitude: 0.45,\n\t          offset: 0,\n\t          strokeWidth: 5\n\t        };\n\t\n\t        return [_extends({}, sharedProperties, {\n\t          frequency: baseFrequency,\n\t          color: (0, _utils.convertHexToRGBA)(_constants.COLORS.tertiary[500], 0.6)\n\t        }), _extends({}, sharedProperties, {\n\t          frequency: baseFrequency * 1.25,\n\t          color: (0, _utils.convertHexToRGBA)(_constants.COLORS.secondary[500], 0.6)\n\t        }), _extends({}, sharedProperties, {\n\t          frequency: baseFrequency * 1.5,\n\t          color: (0, _utils.convertHexToRGBA)(_constants.COLORS.primary[500], 0.6)\n\t        })];\n\t      }\n\t\n\t    case 'harmonics':\n\t      return [].concat(getHarmonicsForWave({\n\t        harmonicsForShape: harmonicsForShape,\n\t        baseFrequency: baseFrequency,\n\t        baseAmplitude: baseAmplitude,\n\t        maxNumberToGenerate: numOfHarmonics,\n\t        strokeWidth: 5,\n\t        color: (0, _utils.convertHexToRGBA)(_constants.COLORS.secondary[500], 0.6)\n\t      }), [{\n\t        shape: 'sine',\n\t        frequency: baseFrequency,\n\t        amplitude: baseAmplitude,\n\t        offset: 0,\n\t        strokeWidth: 5,\n\t        color: (0, _utils.convertHexToRGBA)(_constants.COLORS.primary[500], 0.6)\n\t      }]);\n\t\n\t    default:\n\t      throw new Error('Unrecognized type for `IntroRouteWaveformAddition`');\n\t  }\n\t};\n\n/***/ }),\n\n/***/ 125:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/banner.63f89782.jpg\";\n\n/***/ }),\n\n/***/ 126:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/pic01.f3e58a3f.jpg\";\n\n/***/ }),\n\n/***/ 208:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _waveform = __webpack_require__(205);\n\t\n\tvar _banner = __webpack_require__(125);\n\t\n\tvar _banner2 = _interopRequireDefault(_banner);\n\t\n\tvar _pic = __webpack_require__(126);\n\t\n\tvar _pic2 = _interopRequireDefault(_pic);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Animation = function (_React$Component) {\n\t  _inherits(Animation, _React$Component);\n\t\n\t  function Animation() {\n\t    _classCallCheck(this, Animation);\n\t\n\t    var _this = _possibleConstructorReturn(this, _React$Component.call(this));\n\t\n\t    _this.state = {\n\t      offset: 0\n\t    };\n\t    return _this;\n\t  }\n\t\n\t  Animation.prototype.componentDidMount = function componentDidMount() {\n\t    var _this2 = this;\n\t\n\t    var animate = function animate() {\n\t      _this2.updateProgress();\n\t      window.requestAnimationFrame(animate);\n\t    };\n\t    animate();\n\t  };\n\t\n\t  Animation.prototype.updateProgress = function updateProgress() {\n\t    this.setState(function (previousState, props) {\n\t      return { offset: previousState.offset + props.speed };\n\t    });\n\t  };\n\t\n\t  Animation.prototype.render = function render() {\n\t    var props = {\n\t      color: 'black',\n\t      strokeWidth: '50px',\n\t      opacity: 0.5,\n\t      width: 200,\n\t      height: 1000,\n\t      frequency: 0.2,\n\t      amplitude: 0.75,\n\t      shape: 'sine'\n\t    };\n\t    var color = props.color,\n\t        strokeWidth = props.strokeWidth,\n\t        strokeLinecap = props.strokeLinecap,\n\t        width = props.width,\n\t        height = props.height,\n\t        shape = props.shape,\n\t        frequency = props.frequency,\n\t        amplitude = props.amplitude;\n\t\n\t\n\t    var points = (0, _waveform.getPointsForWaveform)({\n\t      shape: shape,\n\t      frequency: frequency,\n\t      amplitude: amplitude,\n\t      width: width,\n\t      offset: this.state.offset\n\t    }).map(function (point) {\n\t      var relativeY = (0, _waveform.translateAxisRelativeYValue)(point.y, height);\n\t      return {\n\t        x: point.x,\n\t        y: relativeY\n\t      };\n\t    });\n\t\n\t    var svgPath = (0, _waveform.createSVGPathFromWaveformPoints)(points, height);\n\t\n\t    var cx = width / 2 + this.state.offset;\n\t    var cy = height / 2;\n\t    var r = height / 2;\n\t    // return (\n\t    //   <svg width={width} height={height} style={{ overflow: 'visible' }}>\n\t    //     <defs>\n\t    //       <clipPath id='circle-clip'>\n\t    //         <circle cx={cx} cy={cy} r={r} />\n\t    //       </clipPath>\n\t    //     </defs>\n\t    //     <circle cx={cx} cy={cy} r={r} fill='none' stroke='black' />\n\t    //     <path\n\t    //       id='waveform'\n\t    //       d={svgPath}\n\t    //       stroke={color}\n\t    //       strokeWidth={strokeWidth}\n\t    //       strokeLinecap={strokeLinecap}\n\t    //       fill='none'\n\t    //       clipPath='url(#circle-clip)'\n\t    //     />\n\t    //   </svg>\n\t    // )\n\t    return _react2.default.createElement(\n\t      'svg',\n\t      { width: 0, height: 0, style: { overflow: 'visible' } },\n\t      _react2.default.createElement(\n\t        'defs',\n\t        null,\n\t        _react2.default.createElement(\n\t          'clipPath',\n\t          { id: 'waveform' },\n\t          _react2.default.createElement('path', {\n\t            d: svgPath,\n\t            stroke: color,\n\t            strokeWidth: strokeWidth,\n\t            strokeLinecap: strokeLinecap,\n\t            fill: 'none',\n\t            clipPath: 'url(#circle-clip)'\n\t          })\n\t        )\n\t      ),\n\t      _react2.default.createElement('path', {\n\t        d: svgPath,\n\t        stroke: color,\n\t        strokeWidth: strokeWidth,\n\t        strokeLinecap: strokeLinecap,\n\t        fill: 'none',\n\t        clipPath: 'url(#circle-clip)'\n\t      })\n\t    );\n\t  };\n\t\n\t  return Animation;\n\t}(_react2.default.Component);\n\t\n\tAnimation.defaultProps = {\n\t  speed: 0.1\n\t};\n\t\n\texports.default = function () {\n\t  return _react2.default.createElement(\n\t    'div',\n\t    null,\n\t    _react2.default.createElement(Animation, null),\n\t    _react2.default.createElement('img', { id: 'hero', src: _banner2.default })\n\t  );\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 212:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports.requestAnimationFramePromise = requestAnimationFramePromise;\n\texports.setTimeoutPromise = setTimeoutPromise;\n\tvar range = exports.range = function range(start, end, step) {\n\t  var range = [];\n\t  var typeofStart = typeof start;\n\t  var typeofEnd = typeof end;\n\t\n\t  if (step === 0) {\n\t    throw TypeError('Step cannot be zero.');\n\t  }\n\t\n\t  if (typeof end === 'undefined' && typeof 'step' === 'undefined') {\n\t    end = start;\n\t    start = 0;\n\t    typeofStart = typeof start;\n\t    typeofEnd = typeof end;\n\t  }\n\t\n\t  if (typeofStart == 'undefined' || typeofEnd == 'undefined') {\n\t    throw TypeError('Must pass start and end arguments.');\n\t  } else if (typeofStart != typeofEnd) {\n\t    throw TypeError('Start and end arguments must be of same type.');\n\t  }\n\t\n\t  typeof step === 'undefined' && (step = 1);\n\t\n\t  if (end < start) {\n\t    step = -step;\n\t  }\n\t\n\t  if (typeofStart == 'number') {\n\t    while (step > 0 ? end >= start : end <= start) {\n\t      range.push(start);\n\t      start += step;\n\t    }\n\t  } else if (typeofStart == 'string') {\n\t    if (start.length != 1 || end.length != 1) {\n\t      throw TypeError('Only strings with one character are supported.');\n\t    }\n\t\n\t    start = start.charCodeAt(0);\n\t    end = end.charCodeAt(0);\n\t\n\t    while (step > 0 ? end >= start : end <= start) {\n\t      range.push(String.fromCharCode(start));\n\t      start += step;\n\t    }\n\t  } else {\n\t    throw TypeError('Only string and number types are supported');\n\t  }\n\t\n\t  return range;\n\t};\n\t/* eslint-enable */\n\t\n\tvar sample = exports.sample = function sample(arr) {\n\t  return arr[Math.floor(Math.random() * arr.length)];\n\t};\n\t\n\tvar random = exports.random = function random(min, max) {\n\t  return Math.floor(Math.random() * (max - min)) + min;\n\t};\n\t\n\tvar sum = exports.sum = function sum(values) {\n\t  return values.reduce(function (sum, value) {\n\t    return sum + value;\n\t  }, 0);\n\t};\n\tvar mean = exports.mean = function mean(values) {\n\t  return sum(values) / values.length;\n\t};\n\t\n\tvar clamp = exports.clamp = function clamp(val) {\n\t  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\t  return Math.max(min, Math.min(max, val));\n\t};\n\t\n\tvar roundTo = exports.roundTo = function roundTo(number) {\n\t  var places = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t  return Math.round(number * Math.pow(10, places)) / Math.pow(10, places);\n\t};\n\t\n\tvar debounce = exports.debounce = function debounce(callback, wait) {\n\t  var timeoutId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    window.clearTimeout(timeoutId);\n\t\n\t    timeoutId = setTimeout(function () {\n\t      callback.apply(null, args);\n\t    }, wait);\n\t  };\n\t};\n\t\n\tvar isEmpty = exports.isEmpty = function isEmpty(obj) {\n\t  return Object.keys(obj).length === 0;\n\t};\n\t\n\tvar omit = exports.omit = function omit(obj, key) {\n\t  var newObj = {};\n\t\n\t  for (var name in obj) {\n\t    if (name !== key) {\n\t      newObj[name] = obj[name];\n\t    }\n\t  }\n\t\n\t  return newObj;\n\t};\n\t\n\tvar convertArrayToMap = exports.convertArrayToMap = function convertArrayToMap(list) {\n\t  return list.reduce(function (acc, item) {\n\t    var _extends2;\n\t\n\t    return _extends({}, acc, (_extends2 = {}, _extends2[item.id] = item, _extends2));\n\t  }, {});\n\t};\n\t\n\t// Either removes or adds an item to an array\n\t// EXAMPLE: toggleInArray([1, 2], 3) -> [1, 2, 3]\n\t// EXAMPLE: toggleInArray([1, 2], 2) -> [1]\n\tvar toggleInArray = exports.toggleInArray = function toggleInArray(arr, item) {\n\t  return arr.includes(item) ? arr.filter(function (i) {\n\t    return i !== item;\n\t  }) : [].concat(arr, [item]);\n\t};\n\t\n\t// Combines 2 arrays, removing duplicates.\n\t// EXAMPLE: mergeUnique([1, 2], [2, 3]) -> [1, 2, 3]\n\tvar mergeUnique = exports.mergeUnique = function mergeUnique(arr1, arr2) {\n\t  return arr1.concat(arr2.filter(function (item) {\n\t    return arr1.indexOf(item) === -1;\n\t  }));\n\t};\n\t\n\tvar findRight = exports.findRight = function findRight(arr, predicate) {\n\t  return arr.slice().reverse().find(predicate);\n\t};\n\t\n\tfunction requestAnimationFramePromise() {\n\t  return new Promise(function (resolve) {\n\t    return window.requestAnimationFrame(resolve);\n\t  });\n\t}\n\t\n\tfunction setTimeoutPromise(duration) {\n\t  return new Promise(function (resolve) {\n\t    return window.setTimeout(resolve, duration);\n\t  });\n\t}\n\t\n\tvar deleteCookie = exports.deleteCookie = function deleteCookie(key) {\n\t  document.cookie = encodeURIComponent(key) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT';\n\t};\n\t\n\tvar convertHexToRGBA = exports.convertHexToRGBA = function convertHexToRGBA(hex) {\n\t  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t  var r = parseInt(hex.slice(1, 3), 16);\n\t  var g = parseInt(hex.slice(3, 5), 16);\n\t  var b = parseInt(hex.slice(5, 7), 16);\n\t\n\t  return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-hero-js-7cfd1de9034d77343d06.js","// Logic\nexport const WAVEFORM_ASPECT_RATIO = 1\nexport const DEFAULT_WAVEFORM_SHAPE = 'sine'\nexport const DEFAULT_WAVEFORM_SIZE = 200\nexport const DEFAULT_WAVEFORM_NUM_OF_CYCLES = 1\nexport const DEFAULT_WAVEFORM_AMPLITUDE = 1\n\nexport const SHAPES = ['sine', 'triangle', 'square', 'sawtooth']\n\nexport const SPRING_SETTINGS = {\n  stiffness: 170,\n  damping: 26,\n  precision: 0.1\n}\n\nexport const COLORS = {\n  red: {\n    '100': '#FFCDD2',\n    '300': '#E57373',\n    '500': '#F44336',\n    '700': '#D32F2F',\n    '900': '#B71C1C'\n  },\n  orange: {\n    '100': '#FFECB3',\n    '300': '#FFD54F',\n    '500': '#FFC107',\n    '700': '#FFA000',\n    '900': '#ee7314'\n  },\n  green: {\n    '100': '#DCEDC8',\n    '300': '#AED581',\n    '500': '#8BC34A',\n    '700': '#689F38',\n    '900': '#33691E'\n  },\n  indigo: {\n    '100': '#b3defc',\n    '300': '#4f9ef7',\n    '500': '#0380f4',\n    '700': '#0268d1',\n    '900': '#01499b'\n  },\n  blue: {\n    '100': '#B3E5FC',\n    '300': '#4FC3F7',\n    '500': '#03A9F4',\n    '700': '#0288D1',\n    '900': '#01579B'\n  },\n  purple: {\n    '100': '#E1BEE7',\n    '300': '#BA68C8',\n    '500': '#9C27B0',\n    '700': '#7B1FA2',\n    '900': '#4A148C'\n  },\n  pink: {\n    '100': '#F8BBD0',\n    '300': '#F06292',\n    '500': '#E91E63',\n    '700': '#C2185B',\n    '900': '#880E4F'\n  },\n  gray: {\n    '50': '#FAFAFA',\n    '100': '#F5F5F5',\n    '300': '#E0E0E0',\n    '400': '#CCCCCC',\n    '500': '#9E9E9E',\n    '700': '#616161',\n    '800': '#414141',\n    '900': '#212121'\n  },\n  cream: {\n    '50': '#FFFEFC'\n  },\n  white: '#FFFFFF'\n}\n\nCOLORS.primary = COLORS.indigo\nCOLORS.secondary = COLORS.pink\nCOLORS.tertiary = COLORS.orange\n\n// Media queries\nexport const BREAKPOINT_SIZES = {\n  xs: 320,\n  sm: 540,\n  md: 900,\n  lg: 1100,\n  xl: 1440\n}\n\nexport const BREAKPOINTS = {\n  xs: `(max-width: ${BREAKPOINT_SIZES.xs}px)`,\n  sm: `(max-width: ${BREAKPOINT_SIZES.sm}px)`,\n  md: `(max-width: ${BREAKPOINT_SIZES.md}px)`,\n  lg: `(max-width: ${BREAKPOINT_SIZES.lg}px)`,\n  xl: `(max-width: ${BREAKPOINT_SIZES.xl}px)`,\n  xsMin: `(min-width: ${BREAKPOINT_SIZES.xs}px)`,\n  smMin: `(min-width: ${BREAKPOINT_SIZES.sm}px)`,\n  mdMin: `(min-width: ${BREAKPOINT_SIZES.md}px)`,\n  lgMin: `(min-width: ${BREAKPOINT_SIZES.lg}px)`,\n  xlMin: `(min-width: ${BREAKPOINT_SIZES.xl}px)`,\n  desktop: `(min-width: ${BREAKPOINT_SIZES.sm + 1}px)`\n}\n\nexport const MAX_WIDTH = {\n  sm: '100%',\n  md: BREAKPOINT_SIZES.md + 'px',\n  base: BREAKPOINT_SIZES.lg + 'px'\n}\n\nconst mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i\nexport const IS_MOBILE_USER_AGENT = mobileRegex.test(navigator.userAgent)\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants/index.js","import { COLORS } from '../constants'\nimport { range, sum, convertHexToRGBA } from '../utils'\n\n/**\n * This method gets an array of axis-relative points that can be used for\n * further calculations.\n * Given a waveform shape, and some information about its frequency/offset/size,\n * this method returns an array of X/Y values that describes the waveform.\n * This is NOT plot-ready, since the Y values range from -1 to 1.\n * Further processing is required to get something drawable.\n */\nexport const getPointsForWaveform = ({\n  shape,\n  frequency,\n  amplitude,\n  width,\n  offset = 0\n}) => {\n  // Get an array of `x` values.\n  // For now, we're drawing lines at every second point, for performance.\n  // After experimentation, this may change.\n  const ratioBetweenPointsAndPixels = 2\n  const xValues = range(0, width + 1, ratioBetweenPointsAndPixels)\n  // Convert each X value to a proper coordinate system, relative to the axis\n  // (so, Y values will be from -1 to 1)\n  const rawValues = xValues.map(x => {\n    // We need a progress value, to help inform where this `x` value is, in\n    // terms of the cycles drawn.\n\n    // Start by getting the width of a single cycle.\n    // If `frequency` is `1`, then this is just the whole width.\n    // If we're drawing more/less than a single cycle, though, we need to do\n    // some division.\n    const widthOfSingleCycle = width / frequency\n\n    // Next, we need to figure out the progress in terms of the cycle.\n    // If the frequency is 4, This progress will be a value from 0 to 4.\n    const progressRelativeToCycles = x / widthOfSingleCycle\n\n    // Finally, we have to take the waveform's offset into account.\n    // As a refresher: `offset` ranges from 0 to 99, and it controls how much\n    // to shift the waveform by.\n    // Example: A sine wave with 50 offset will look like an inverted sine wave.\n    // The `* 100` is necessary since offset is 0-99 instead of 0-1.\n    // TODO: Probably makes sense to keep it from 0-1, makes more semantic sense\n    const progress = progressRelativeToCycles * 100 + offset\n    return {\n      x,\n      y: getPositionAtPointRelativeToAxis(shape, frequency, amplitude, progress)\n    }\n  })\n\n  if (shape === 'triangle') {\n    // Find the peak points in the wave, and set it to max amplitude.\n    fixPeaks(amplitude, rawValues)\n  }\n\n  return rawValues\n}\n\n// HACK HACK HACK: So, the current method I have for generating waveforms is\n// flawed, in that it produces glitchy peaks because of rounding errors.\n// The proper solution eludes me, but I did find this mathy way of fixing it.\n// I'll go through and find those 'peak' values, and adjust their coordinates to\n// actually sit at the peak.\nconst fixPeaks = (amplitude, values) => {\n  return values.forEach((value, index) => {\n    if (index <= 2 || index === values.length - 1) {\n      return\n    }\n\n    const previousVal = values[index - 1]\n    const nextVal = values[index + 1]\n\n    if (\n      Math.abs(value.y) > Math.abs(previousVal.y) &&\n      Math.abs(value.y) > Math.abs(nextVal.y)\n    ) {\n      // Is a peak!\n      // Figure out the slope of the line.\n      const previousPreviousVal = values[index - 2]\n\n      const slope =\n        (previousVal.y - previousPreviousVal.y) /\n        (previousVal.x - previousPreviousVal.x)\n\n      value.y = value.y < 0 ? -amplitude : amplitude\n\n      value.x = (value.y - previousVal.y) / slope + previousVal.x\n    }\n  })\n}\n\nexport const createSVGPathFromWaveformPoints = (points, height) =>\n  points.reduce((acc, { x, y }, index) => {\n    // For the very first point, we have to Move to that area\n    if (index === 0) {\n      return `M ${x},${y} `\n    }\n\n    // For all subsequent points, we can just draw a line to it.\n    return `${acc} L ${x},${y}`\n  }, '')\n/**\n * Given progress between 0 and 100, figure out the Y position, relative\n * to the X axis (from 1 to -1)\n */\nexport const getPositionAtPointRelativeToAxis = (\n  shape,\n  frequency,\n  amplitude,\n  progress\n) => {\n  switch (shape) {\n    case 'sine': {\n      // Each sine cycle is 2Pi long, in trigonometry terms.\n      // The frequency determines how many cycles are in the available space.\n      const cycleLength = Math.PI * 2\n      const totalLength = cycleLength * frequency\n\n      // the progress is through the given cycle, but we may be rendering\n      // multiple cycles.\n      const progressThroughDrawableArea = progress * (1 / frequency)\n\n      // Right now, `progress` ranges from 0 to 100.\n      // Normalize this value to fit between 0 and `totalLength`.\n      // Just cross-multiplying to get the normalized value:\n      //\n      // progress         positionInRads\n      // --------  =      --------------\n      //   100             totalLength\n      //\n      // prettier-ignore\n      const positionInRads = (progressThroughDrawableArea * totalLength) / 100\n\n      // Now we can simply take the sin of the rad position to get a value,\n      // from -1 to 1. We multiply by amplitude (a value between 0 and 1) to\n      // make sure the waveform isn't more powerful than desired.\n      return Math.sin(positionInRads) * amplitude\n    }\n\n    case 'square': {\n      // Square waves are easy; the value is either `amplitude` or `-amplitude`.\n      // Figure out how far we are through the current iteration, since the\n      // drawable wave might have multiple iterations if frequency > 1Hz.\n      const progressThroughIteration = progress % 100\n\n      return progressThroughIteration < 50 ? amplitude : -amplitude\n    }\n\n    case 'sawtooth': {\n      // Each sawtooth iteration simply ranges from `-amplitude` to `amplitude`\n      // in a linear way.\n\n      const progressThroughIteration = progress % 100\n\n      // Normally, this would be a simple cross-multiplication to normalize\n      // between min and max, but our min is a negative number. Start by\n      // adding that amount so that it ranges from `0 - 2*amplitude`\n      const adjustedMax = amplitude * 2\n\n      return progressThroughIteration * adjustedMax / 100 - amplitude\n    }\n\n    case 'triangle': {\n      // This waveform might include multiple iterations, if frequency > 1Hz.\n      // This is an easy thing to solve, though; make it cyclical so that we're\n      // only looking at values from 0 to 99.\n      const progressThroughIteration = progress % 100\n\n      // Each triangle iteration has 4 quadrants of equal size:\n      // - the initial ramp up from 0 to 1\n      // - the ramp down from 1 to 0,\n      // - another from 0 to -1\n      // - the final ramp back up from -1 to 0.\n      //\n      //  Q1 | Q2 |    |\n      //    /|\\   |    |\n      //  /  |  \\ |    |\n      //  ---|---\\|--- |-----/--------------------------------\n      //     |    | \\  |   /\n      //     |    |  \\ | /\n      //     |    | Q3 | Q4\n      //\n      // Our `progressThroughIteration` is a value from 0 to 99, so we can\n      // figure out which quadrant it's in by dividing this number by 4.\n      //\n      // (Adding 1 so that it ranges from 1-4 instead of 0.3. So that, for\n      // example, 'second quadrant' is unambiguous.)\n      const quadrant = Math.floor(progressThroughIteration / 25) + 1\n\n      const progressThroughQuadrant = progress % 25\n\n      switch (quadrant) {\n        case 1: {\n          // Quadrant 1 is easy, since it ranges from 0 to 1.\n          // To get the value from 0 to 1, just divide progress by the\n          // quadrant max (25). Then, to get the amplitude, multiply by the\n          // wave's actual amplitude.\n          //\n          // To understand the `* amplitude` bit, remember that the wave's\n          // amplitude ranges from 0 to 1.\n          // If the wave is at max loudness, this value wouldn't be necessary\n          // (since `* 1` can always be omitted).\n          // If the wave is at half amplitude, though, our triangle's peak\n          // should be halfway up from the X-axis. So we multiply by 0.5.\n          return progressThroughQuadrant / 25 * amplitude\n        }\n\n        case 2: {\n          // Quadrant 2 is similar to quadrant 1, but reversed. Going from 1-0.\n          // To solve this, we can simply subtract the value from our max\n          // amplitude.\n          // Again, if we're at max amplitude, this would just be `1 - stuff`.\n          // Since we want to \"invert\" it vertically:\n          //\n          // Value  |  Inverted value\n          // 1      |  0\n          // 0.25   |  0.75\n          // 0.5    |  0.5\n          //\n          // See how you can \"invert\" each value by subtracting it from 1?\n          //\n          // But yeah, because our max amplitude can be less than 1, we have\n          // to use `amplitude` instead of `1`.\n          return amplitude - progressThroughQuadrant / 25 * amplitude\n        }\n\n        case 3: {\n          // Our third quadrant ranges from 0 to -1.\n          // This is getting more complicated, but it's really just building on\n          // the previous 2 quadrants.\n          //\n          // Quadrant 3 is identical to quadrant 2 except that it's lower.\n          // If amplitude is 1, you could think of quadrant 2 as being 1 lower\n          // than quadrant 3.\n          //\n          // By subtracting our max amplitude from the end of the Q2 formula,\n          // we lower it accordingly.\n          return (\n            amplitude - progressThroughQuadrant / 25 * amplitude - amplitude\n          )\n        }\n\n        case 4: {\n          // Finally, our final quadrant ranges from -1 to 0.\n          // Similar to how Q3 was just Q2 minus amplitude, Q4 is really just\n          // Q1 minus amplitude.\n          //\n          // This make sense when you think about it. Q3 is just Q2 but lower.\n          // Similarly, Q4 is just Q1 but lower.\n          return progressThroughQuadrant / 25 * amplitude - amplitude\n        }\n\n        default: {\n          // Should be impossible\n          throw new Error('Unrecognized quadrant!')\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unrecognized waveform shape supplied: ' + shape)\n  }\n}\n\nexport const translateAxisRelativeYValue = (\n  // a value from -1 to 1 (relative to the axis)\n  yValue,\n  // The height in pixels of our waveform drawing\n  height\n) => {\n  // Invert the y value. This is so that negative values are below the line,\n  // while positive ones are above it.\n  yValue *= -1\n\n  // Start by changing the range of the yValue:\n  // -1...1 -> 0...2\n  const incrementedYValue = yValue + 1\n\n  // Now we can just cross-multiply!\n  //     Y              X\n  //  ------    =    ------\n  //     2           height\n  //\n  // prettier-ignore\n  return (incrementedYValue * height) / 2\n}\n\nexport const getInterceptPosition = (\n  shape,\n  height,\n  frequency,\n  amplitude,\n  progress\n) => {\n  const relativePosition = getPositionAtPointRelativeToAxis(\n    shape,\n    frequency,\n    amplitude,\n    progress\n  )\n\n  return translateAxisRelativeYValue(relativePosition, height)\n}\n\nexport const applyWaveformAddition = (\n  mainWave,\n  appliedWaves,\n  // ratio is the \"effect\" of the applied wave on the main wave, from 0-1.\n  ratio\n) => {\n  if (ratio === 0) {\n    // At 0, it has no effect. We can just return the main wave as-is.\n    return mainWave\n  }\n\n  // For everything in-between, the applied wave adjusts the main wave by the\n  // amount specified.\n  return mainWave.map((point, index) => {\n    const appliedWavesAtPoint = sum(appliedWaves.map(wave => wave[index].y))\n\n    const mainValue = point.y * (1 - ratio)\n    const appliedValue = appliedWavesAtPoint * ratio\n\n    return {\n      x: point.x,\n      y: mainValue + appliedValue\n    }\n  })\n}\n\nexport const convertProgressToCycle = progress => (progress * 100) % 100\n\nexport const getHarmonicsForWave = ({\n  harmonicsForShape = 'sine',\n  baseFrequency,\n  baseAmplitude,\n  maxNumberToGenerate,\n  ...delegated\n}) => {\n  if (maxNumberToGenerate === 0) {\n    return []\n  }\n\n  switch (harmonicsForShape) {\n    // Sine waves have no harmonics\n    case 'sine':\n      return []\n\n    case 'sawtooth': {\n      return range(1, maxNumberToGenerate).map(i => {\n        // the first index would be our main wave; we're only interested in the\n        // harmonics.\n        const harmonicIndex = i + 1\n\n        const frequency = baseFrequency * harmonicIndex\n        const amplitude = baseAmplitude / harmonicIndex\n\n        return { shape: 'sine', frequency, amplitude, ...delegated }\n      })\n    }\n\n    case 'square': {\n      return range(1, maxNumberToGenerate).map(i => {\n        // Our index will be simple increments (1,2,3,4...)\n        // We're only interested in ODD harmonics for square waves, though\n        // (3, 5, 7, 9...)\n        //\n        // We want to do the following conversion:\n        //\n        // Index | Harmonic\n        //   1   |    3\n        //   2   |    5\n        //   3   |    7\n        //   4   |    9\n        //\n        // Looking at the numbers, a simple formula presents itself:\n        const harmonicIndex = i * 2 + 1\n\n        const frequency = baseFrequency * harmonicIndex\n        const amplitude = baseAmplitude / harmonicIndex\n\n        return { shape: 'sine', frequency, amplitude, ...delegated }\n      })\n    }\n\n    case 'triangle': {\n      // Triangles are similar to squares - they feature odd harmonics at\n      // ever-increasing amplitudes - but with one wrinkle: the phase is\n      // inverted for every second harmonic.\n      return range(1, maxNumberToGenerate).map(i => {\n        const harmonicIndex = i * 2 + 1\n\n        // Triangles alternate phases.\n        // To understand this, first we need to understand that these two things\n        // are equivalent:\n        //\n        // - cut the offset of the waveform by π (AKA 50%)\n        // - Multiplying the amplitude by -1\n        //\n        // The reason for this makes sense if you imagine both scenarios.\n        // A periodic waveform like the triangle can be thought of in 2 \"halves\"\n        // the first half is a positive triangle, the second half is negative.\n        //\n        //   First\n        //    /\\ |\n        //  /   \\|\n        //  -----|------/-\n        //       |\\   /\n        //       | \\/\n        //       |Second\n        //\n        // When we rotate the offset by 50%, we invert it:\n        //\n        //           Second\n        //             /\\\n        //           /   \\\n        //  \\------/------\\\n        //   \\   /\n        //    \\/\n        //  First\n        //\n        // Similarly, if we multiply every point's amplitude by -1, we achieve\n        // the exact same effect, through a different mechanism; instead of\n        // pulling the waveform forward by 50%, we rotate it across a 3D axis\n        // (imagine flipping a sign away from you to be upside down).\n        //\n        // So yeah, for triangles to work, we need to invert every second\n        // wave that we add.\n        const isOddHarmonic = i % 2 !== 0\n        const amplitudePhaseMultiplier = isOddHarmonic ? -1 : 1\n\n        const frequency = baseFrequency * harmonicIndex\n        const amplitude =\n          baseAmplitude / harmonicIndex ** 2 * amplitudePhaseMultiplier\n\n        return { shape: 'sine', frequency, amplitude, ...delegated }\n      })\n    }\n\n    default:\n      return []\n  }\n}\n\nexport const getWaveforms = ({\n  type,\n  harmonicsForShape,\n  phase = 0,\n  baseFrequency,\n  baseAmplitude,\n  numOfHarmonics\n}) => {\n  switch (type) {\n    case 'phase': {\n      // Our phase ranges from 0 to 360, but we need to convert that to our\n      // 0-100 offset for the waves. Additionally, we want the value to go\n      // from 100-o, so that the phase moves to the right instead of the left.\n      const offset = 100 - phase * 100 / 360\n\n      return [\n        {\n          shape: 'sine',\n          frequency: baseFrequency,\n          amplitude: baseAmplitude * 0.5,\n          offset,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.secondary[500], 0.6)\n        },\n        {\n          shape: 'sine',\n          frequency: baseFrequency,\n          amplitude: baseAmplitude * 0.5,\n          offset: 0,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.primary[500], 0.6)\n        }\n      ]\n    }\n\n    case 'chord': {\n      const sharedProperties = {\n        shape: 'sine',\n        amplitude: 0.45,\n        offset: 0,\n        strokeWidth: 5\n      }\n\n      return [\n        {\n          ...sharedProperties,\n          frequency: baseFrequency,\n          color: convertHexToRGBA(COLORS.tertiary[500], 0.6)\n        },\n        {\n          ...sharedProperties,\n          frequency: baseFrequency * 1.25,\n          color: convertHexToRGBA(COLORS.secondary[500], 0.6)\n        },\n        {\n          ...sharedProperties,\n          frequency: baseFrequency * 1.5,\n          color: convertHexToRGBA(COLORS.primary[500], 0.6)\n        }\n      ]\n    }\n\n    case 'harmonics':\n      return [\n        ...getHarmonicsForWave({\n          harmonicsForShape,\n          baseFrequency,\n          baseAmplitude,\n          maxNumberToGenerate: numOfHarmonics,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.secondary[500], 0.6)\n        }),\n        {\n          shape: 'sine',\n          frequency: baseFrequency,\n          amplitude: baseAmplitude,\n          offset: 0,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.primary[500], 0.6)\n        }\n      ]\n\n    default:\n      throw new Error('Unrecognized type for `IntroRouteWaveformAddition`')\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/waveform.helpers.js","module.exports = __webpack_public_path__ + \"static/banner.63f89782.jpg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/images/banner.jpg\n// module id = 125\n// module chunks = 35783957827783 46383895804194","module.exports = __webpack_public_path__ + \"static/pic01.f3e58a3f.jpg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/images/pic01.jpg\n// module id = 126\n// module chunks = 46383895804194 76758144387212","import React from 'react'\nimport {\n  getPointsForWaveform,\n  createSVGPathFromWaveformPoints,\n  translateAxisRelativeYValue\n} from '../helpers/waveform.helpers'\n\nimport bannerImageSource from '../images/banner.jpg'\nimport pic01Source from '../images/pic01.jpg'\n\nclass Animation extends React.Component {\n  constructor () {\n    super()\n    this.state = {\n      offset: 0\n    }\n  }\n  componentDidMount () {\n    const animate = () => {\n      this.updateProgress()\n      window.requestAnimationFrame(animate)\n    }\n    animate()\n  }\n  updateProgress () {\n    this.setState((previousState, props) => {\n      return { offset: previousState.offset + props.speed }\n    })\n  }\n  render () {\n    const props = {\n      color: 'black',\n      strokeWidth: '50px',\n      opacity: 0.5,\n      width: 200,\n      height: 1000,\n      frequency: 0.2,\n      amplitude: 0.75,\n      shape: 'sine'\n    }\n    const {\n      color,\n      strokeWidth,\n      strokeLinecap,\n      width,\n      height,\n      shape,\n      frequency,\n      amplitude\n    } = props\n\n    const points = getPointsForWaveform({\n      shape,\n      frequency,\n      amplitude,\n      width,\n      offset: this.state.offset\n    }).map(point => {\n      const relativeY = translateAxisRelativeYValue(point.y, height)\n      return {\n        x: point.x,\n        y: relativeY\n      }\n    })\n\n    const svgPath = createSVGPathFromWaveformPoints(points, height)\n\n    const cx = width / 2 + this.state.offset\n    const cy = height / 2\n    const r = height / 2\n    // return (\n    //   <svg width={width} height={height} style={{ overflow: 'visible' }}>\n    //     <defs>\n    //       <clipPath id='circle-clip'>\n    //         <circle cx={cx} cy={cy} r={r} />\n    //       </clipPath>\n    //     </defs>\n    //     <circle cx={cx} cy={cy} r={r} fill='none' stroke='black' />\n    //     <path\n    //       id='waveform'\n    //       d={svgPath}\n    //       stroke={color}\n    //       strokeWidth={strokeWidth}\n    //       strokeLinecap={strokeLinecap}\n    //       fill='none'\n    //       clipPath='url(#circle-clip)'\n    //     />\n    //   </svg>\n    // )\n    return (\n      <svg width={0} height={0} style={{ overflow: 'visible' }}>\n        <defs>\n          <clipPath id='waveform'>\n            <path\n              d={svgPath}\n              stroke={color}\n              strokeWidth={strokeWidth}\n              strokeLinecap={strokeLinecap}\n              fill='none'\n              clipPath='url(#circle-clip)'\n            />\n          </clipPath>\n        </defs>\n        <path\n          d={svgPath}\n          stroke={color}\n          strokeWidth={strokeWidth}\n          strokeLinecap={strokeLinecap}\n          fill='none'\n          clipPath='url(#circle-clip)'\n        />\n      </svg>\n    )\n  }\n}\n\nAnimation.defaultProps = {\n  speed: 0.1\n}\n\nexport default () => {\n  return (\n    <div>\n      <Animation />\n      <img id='hero' src={bannerImageSource} />\n    </div>\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/hero.js","export const range = function (start, end, step) {\n  var range = []\n  var typeofStart = typeof start\n  var typeofEnd = typeof end\n\n  if (step === 0) {\n    throw TypeError('Step cannot be zero.')\n  }\n\n  if (typeof end === 'undefined' && typeof 'step' === 'undefined') {\n    end = start\n    start = 0\n    typeofStart = typeof start\n    typeofEnd = typeof end\n  }\n\n  if (typeofStart == 'undefined' || typeofEnd == 'undefined') {\n    throw TypeError('Must pass start and end arguments.')\n  } else if (typeofStart != typeofEnd) {\n    throw TypeError('Start and end arguments must be of same type.')\n  }\n\n  typeof step === 'undefined' && (step = 1)\n\n  if (end < start) {\n    step = -step\n  }\n\n  if (typeofStart == 'number') {\n    while (step > 0 ? end >= start : end <= start) {\n      range.push(start)\n      start += step\n    }\n  } else if (typeofStart == 'string') {\n    if (start.length != 1 || end.length != 1) {\n      throw TypeError('Only strings with one character are supported.')\n    }\n\n    start = start.charCodeAt(0)\n    end = end.charCodeAt(0)\n\n    while (step > 0 ? end >= start : end <= start) {\n      range.push(String.fromCharCode(start))\n      start += step\n    }\n  } else {\n    throw TypeError('Only string and number types are supported')\n  }\n\n  return range\n}\n/* eslint-enable */\n\nexport const sample = arr => arr[Math.floor(Math.random() * arr.length)]\n\nexport const random = (min, max) =>\n  Math.floor(Math.random() * (max - min)) + min\n\nexport const sum = values => values.reduce((sum, value) => sum + value, 0)\nexport const mean = values => sum(values) / values.length\n\nexport const clamp = (val, min = 0, max = 1) =>\n  Math.max(min, Math.min(max, val))\n\nexport const roundTo = (number, places = 0) =>\n  Math.round(number * 10 ** places) / 10 ** places\n\nexport const debounce = (callback, wait, timeoutId = null) => (...args) => {\n  window.clearTimeout(timeoutId)\n\n  timeoutId = setTimeout(() => {\n    callback.apply(null, args)\n  }, wait)\n}\n\nexport const isEmpty = obj => Object.keys(obj).length === 0\n\nexport const omit = function (obj, key) {\n  var newObj = {}\n\n  for (var name in obj) {\n    if (name !== key) {\n      newObj[name] = obj[name]\n    }\n  }\n\n  return newObj\n}\n\nexport const convertArrayToMap = list =>\n  list.reduce(\n    (acc, item) => ({\n      ...acc,\n      [item.id]: item\n    }),\n    {}\n  )\n\n// Either removes or adds an item to an array\n// EXAMPLE: toggleInArray([1, 2], 3) -> [1, 2, 3]\n// EXAMPLE: toggleInArray([1, 2], 2) -> [1]\nexport const toggleInArray = (arr, item) =>\n  arr.includes(item) ? arr.filter(i => i !== item) : [...arr, item]\n\n// Combines 2 arrays, removing duplicates.\n// EXAMPLE: mergeUnique([1, 2], [2, 3]) -> [1, 2, 3]\nexport const mergeUnique = (arr1, arr2) =>\n  arr1.concat(arr2.filter(item => arr1.indexOf(item) === -1))\n\nexport const findRight = (arr, predicate) =>\n  arr\n    .slice()\n    .reverse()\n    .find(predicate)\n\nexport function requestAnimationFramePromise () {\n  return new Promise(resolve => window.requestAnimationFrame(resolve))\n}\n\nexport function setTimeoutPromise (duration) {\n  return new Promise(resolve => window.setTimeout(resolve, duration))\n}\n\nexport const deleteCookie = key => {\n  document.cookie = `${encodeURIComponent(\n    key\n  )}=; expires=Thu, 01 Jan 1970 00:00:00 GMT`\n}\n\nexport const convertHexToRGBA = (hex, alpha = 1) => {\n  const r = parseInt(hex.slice(1, 3), 16)\n  const g = parseInt(hex.slice(3, 5), 16)\n  const b = parseInt(hex.slice(5, 7), 16)\n\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/index.js"],"sourceRoot":""}