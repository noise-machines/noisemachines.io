{"version":3,"sources":["webpack:///./src/constants/index.js","webpack:///./src/utils/index.js","webpack:///./src/helpers/waveform.helpers.js","webpack:///./src/pages/hero.js","webpack:///./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack:///./src/images/pic01.jpg","webpack:///./node_modules/core-js/modules/es6.function.name.js","webpack:///./src/images/banner.jpg","webpack:///./node_modules/core-js/modules/es6.object.keys.js","webpack:///./node_modules/core-js/modules/_object-sap.js"],"names":["COLORS","red","100","300","500","700","900","orange","green","indigo","blue","purple","pink","gray","50","400","800","cream","white","primary","secondary","tertiary","range","start","end","step","typeofStart","typeofEnd","TypeError","undefined","push","length","charCodeAt","String","fromCharCode","fixPeaks","amplitude","values","forEach","value","index","previousVal","nextVal","Math","abs","y","previousPreviousVal","slope","x","getPositionAtPointRelativeToAxis","shape","frequency","progress","positionInRads","PI","sin","progressThroughIteration","progressThroughQuadrant","floor","Error","translateAxisRelativeYValue","yValue","height","Animation","_this","_React$Component","call","this","state","offset","componentDidMount","_this2","animate","updateProgress","window","requestAnimationFrame","setState","previousState","props","speed","render","color","strokeWidth","opacity","width","strokeLinecap","svgPath","points","reduce","acc","_ref2","createSVGPathFromWaveformPoints","_ref","_ref$offset","rawValues","map","getPointsForWaveform","point","relativeY","react_default","a","createElement","style","overflow","id","d","stroke","fill","clipPath","React","Component","defaultProps","__webpack_exports__","hero_Animation","src","bannerImageSource","module","exports","source","excluded","key","i","target","sourceKeys","Object","keys","indexOf","__webpack_require__","p","dP","f","FProto","Function","prototype","nameRE","configurable","get","match","e","toObject","$keys","it","$export","core","fails","KEY","exec","fn","exp","S","F"],"mappings":"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","file":"component---src-pages-hero-js-629b5dc0972e44c8a451.js","sourcesContent":["// Logic\nexport const WAVEFORM_ASPECT_RATIO = 1\nexport const DEFAULT_WAVEFORM_SHAPE = 'sine'\nexport const DEFAULT_WAVEFORM_SIZE = 200\nexport const DEFAULT_WAVEFORM_NUM_OF_CYCLES = 1\nexport const DEFAULT_WAVEFORM_AMPLITUDE = 1\n\nexport const SHAPES = ['sine', 'triangle', 'square', 'sawtooth']\n\nexport const SPRING_SETTINGS = {\n  stiffness: 170,\n  damping: 26,\n  precision: 0.1\n}\n\nexport const COLORS = {\n  red: {\n    '100': '#FFCDD2',\n    '300': '#E57373',\n    '500': '#F44336',\n    '700': '#D32F2F',\n    '900': '#B71C1C'\n  },\n  orange: {\n    '100': '#FFECB3',\n    '300': '#FFD54F',\n    '500': '#FFC107',\n    '700': '#FFA000',\n    '900': '#ee7314'\n  },\n  green: {\n    '100': '#DCEDC8',\n    '300': '#AED581',\n    '500': '#8BC34A',\n    '700': '#689F38',\n    '900': '#33691E'\n  },\n  indigo: {\n    '100': '#b3defc',\n    '300': '#4f9ef7',\n    '500': '#0380f4',\n    '700': '#0268d1',\n    '900': '#01499b'\n  },\n  blue: {\n    '100': '#B3E5FC',\n    '300': '#4FC3F7',\n    '500': '#03A9F4',\n    '700': '#0288D1',\n    '900': '#01579B'\n  },\n  purple: {\n    '100': '#E1BEE7',\n    '300': '#BA68C8',\n    '500': '#9C27B0',\n    '700': '#7B1FA2',\n    '900': '#4A148C'\n  },\n  pink: {\n    '100': '#F8BBD0',\n    '300': '#F06292',\n    '500': '#E91E63',\n    '700': '#C2185B',\n    '900': '#880E4F'\n  },\n  gray: {\n    '50': '#FAFAFA',\n    '100': '#F5F5F5',\n    '300': '#E0E0E0',\n    '400': '#CCCCCC',\n    '500': '#9E9E9E',\n    '700': '#616161',\n    '800': '#414141',\n    '900': '#212121'\n  },\n  cream: {\n    '50': '#FFFEFC'\n  },\n  white: '#FFFFFF'\n}\n\nCOLORS.primary = COLORS.indigo\nCOLORS.secondary = COLORS.pink\nCOLORS.tertiary = COLORS.orange\n\n// Media queries\nexport const BREAKPOINT_SIZES = {\n  xs: 320,\n  sm: 540,\n  md: 900,\n  lg: 1100,\n  xl: 1440\n}\n\nexport const BREAKPOINTS = {\n  xs: `(max-width: ${BREAKPOINT_SIZES.xs}px)`,\n  sm: `(max-width: ${BREAKPOINT_SIZES.sm}px)`,\n  md: `(max-width: ${BREAKPOINT_SIZES.md}px)`,\n  lg: `(max-width: ${BREAKPOINT_SIZES.lg}px)`,\n  xl: `(max-width: ${BREAKPOINT_SIZES.xl}px)`,\n  xsMin: `(min-width: ${BREAKPOINT_SIZES.xs}px)`,\n  smMin: `(min-width: ${BREAKPOINT_SIZES.sm}px)`,\n  mdMin: `(min-width: ${BREAKPOINT_SIZES.md}px)`,\n  lgMin: `(min-width: ${BREAKPOINT_SIZES.lg}px)`,\n  xlMin: `(min-width: ${BREAKPOINT_SIZES.xl}px)`,\n  desktop: `(min-width: ${BREAKPOINT_SIZES.sm + 1}px)`\n}\n\nexport const MAX_WIDTH = {\n  sm: '100%',\n  md: BREAKPOINT_SIZES.md + 'px',\n  base: BREAKPOINT_SIZES.lg + 'px'\n}\n","export const range = function (start, end, step) {\n  var range = []\n  var typeofStart = typeof start\n  var typeofEnd = typeof end\n\n  if (step === 0) {\n    throw TypeError('Step cannot be zero.')\n  }\n\n  if (typeof end === 'undefined' && typeof 'step' === 'undefined') {\n    end = start\n    start = 0\n    typeofStart = typeof start\n    typeofEnd = typeof end\n  }\n\n  if (typeofStart === undefined || typeofEnd === 'undefined') {\n    throw TypeError('Must pass start and end arguments.')\n  } else if (typeofStart != typeofEnd) {\n    throw TypeError('Start and end arguments must be of same type.')\n  }\n\n  typeof step === 'undefined' && (step = 1)\n\n  if (end < start) {\n    step = -step\n  }\n\n  if (typeofStart == 'number') {\n    while (step > 0 ? end >= start : end <= start) {\n      range.push(start)\n      start += step\n    }\n  } else if (typeofStart == 'string') {\n    if (start.length != 1 || end.length != 1) {\n      throw TypeError('Only strings with one character are supported.')\n    }\n\n    start = start.charCodeAt(0)\n    end = end.charCodeAt(0)\n\n    while (step > 0 ? end >= start : end <= start) {\n      range.push(String.fromCharCode(start))\n      start += step\n    }\n  } else {\n    throw TypeError('Only string and number types are supported')\n  }\n\n  return range\n}\n/* eslint-enable */\n\nexport const sample = arr => arr[Math.floor(Math.random() * arr.length)]\n\nexport const random = (min, max) =>\n  Math.floor(Math.random() * (max - min)) + min\n\nexport const sum = values => values.reduce((sum, value) => sum + value, 0)\nexport const mean = values => sum(values) / values.length\n\nexport const clamp = (val, min = 0, max = 1) =>\n  Math.max(min, Math.min(max, val))\n\nexport const roundTo = (number, places = 0) =>\n  Math.round(number * 10 ** places) / 10 ** places\n\nexport const debounce = (callback, wait, timeoutId = null) => (...args) => {\n  window.clearTimeout(timeoutId)\n\n  timeoutId = setTimeout(() => {\n    callback.apply(null, args)\n  }, wait)\n}\n\nexport const isEmpty = obj => Object.keys(obj).length === 0\n\nexport const omit = function (obj, key) {\n  var newObj = {}\n\n  for (var name in obj) {\n    if (name !== key) {\n      newObj[name] = obj[name]\n    }\n  }\n\n  return newObj\n}\n\nexport const convertArrayToMap = list =>\n  list.reduce(\n    (acc, item) => ({\n      ...acc,\n      [item.id]: item\n    }),\n    {}\n  )\n\n// Either removes or adds an item to an array\n// EXAMPLE: toggleInArray([1, 2], 3) -> [1, 2, 3]\n// EXAMPLE: toggleInArray([1, 2], 2) -> [1]\nexport const toggleInArray = (arr, item) =>\n  arr.includes(item) ? arr.filter(i => i !== item) : [...arr, item]\n\n// Combines 2 arrays, removing duplicates.\n// EXAMPLE: mergeUnique([1, 2], [2, 3]) -> [1, 2, 3]\nexport const mergeUnique = (arr1, arr2) =>\n  arr1.concat(arr2.filter(item => arr1.indexOf(item) === -1))\n\nexport const findRight = (arr, predicate) =>\n  arr\n    .slice()\n    .reverse()\n    .find(predicate)\n\nexport function requestAnimationFramePromise () {\n  return new Promise(resolve => window.requestAnimationFrame(resolve))\n}\n\nexport function setTimeoutPromise (duration) {\n  return new Promise(resolve => window.setTimeout(resolve, duration))\n}\n\nexport const deleteCookie = key => {\n  document.cookie = `${encodeURIComponent(\n    key\n  )}=; expires=Thu, 01 Jan 1970 00:00:00 GMT`\n}\n\nexport const convertHexToRGBA = (hex, alpha = 1) => {\n  const r = parseInt(hex.slice(1, 3), 16)\n  const g = parseInt(hex.slice(3, 5), 16)\n  const b = parseInt(hex.slice(5, 7), 16)\n\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`\n}\n","import { COLORS } from '../constants'\nimport { range, sum, convertHexToRGBA } from '../utils'\n\n/**\n * This method gets an array of axis-relative points that can be used for\n * further calculations.\n * Given a waveform shape, and some information about its frequency/offset/size,\n * this method returns an array of X/Y values that describes the waveform.\n * This is NOT plot-ready, since the Y values range from -1 to 1.\n * Further processing is required to get something drawable.\n */\nexport const getPointsForWaveform = ({\n  shape,\n  frequency,\n  amplitude,\n  width,\n  offset = 0\n}) => {\n  // Get an array of `x` values.\n  // For now, we're drawing lines at every second point, for performance.\n  // After experimentation, this may change.\n  const ratioBetweenPointsAndPixels = 2\n  const xValues = range(0, width + 1, ratioBetweenPointsAndPixels)\n  // Convert each X value to a proper coordinate system, relative to the axis\n  // (so, Y values will be from -1 to 1)\n  const rawValues = xValues.map(x => {\n    // We need a progress value, to help inform where this `x` value is, in\n    // terms of the cycles drawn.\n\n    // Start by getting the width of a single cycle.\n    // If `frequency` is `1`, then this is just the whole width.\n    // If we're drawing more/less than a single cycle, though, we need to do\n    // some division.\n    const widthOfSingleCycle = width / frequency\n\n    // Next, we need to figure out the progress in terms of the cycle.\n    // If the frequency is 4, This progress will be a value from 0 to 4.\n    const progressRelativeToCycles = x / widthOfSingleCycle\n\n    // Finally, we have to take the waveform's offset into account.\n    // As a refresher: `offset` ranges from 0 to 99, and it controls how much\n    // to shift the waveform by.\n    // Example: A sine wave with 50 offset will look like an inverted sine wave.\n    // The `* 100` is necessary since offset is 0-99 instead of 0-1.\n    // TODO: Probably makes sense to keep it from 0-1, makes more semantic sense\n    const progress = progressRelativeToCycles * 100 + offset\n    return {\n      x,\n      y: getPositionAtPointRelativeToAxis(shape, frequency, amplitude, progress)\n    }\n  })\n\n  if (shape === 'triangle') {\n    // Find the peak points in the wave, and set it to max amplitude.\n    fixPeaks(amplitude, rawValues)\n  }\n\n  return rawValues\n}\n\n// HACK HACK HACK: So, the current method I have for generating waveforms is\n// flawed, in that it produces glitchy peaks because of rounding errors.\n// The proper solution eludes me, but I did find this mathy way of fixing it.\n// I'll go through and find those 'peak' values, and adjust their coordinates to\n// actually sit at the peak.\nconst fixPeaks = (amplitude, values) => {\n  return values.forEach((value, index) => {\n    if (index <= 2 || index === values.length - 1) {\n      return\n    }\n\n    const previousVal = values[index - 1]\n    const nextVal = values[index + 1]\n\n    if (\n      Math.abs(value.y) > Math.abs(previousVal.y) &&\n      Math.abs(value.y) > Math.abs(nextVal.y)\n    ) {\n      // Is a peak!\n      // Figure out the slope of the line.\n      const previousPreviousVal = values[index - 2]\n\n      const slope =\n        (previousVal.y - previousPreviousVal.y) /\n        (previousVal.x - previousPreviousVal.x)\n\n      value.y = value.y < 0 ? -amplitude : amplitude\n\n      value.x = (value.y - previousVal.y) / slope + previousVal.x\n    }\n  })\n}\n\nexport const createSVGPathFromWaveformPoints = (points, height) =>\n  points.reduce((acc, { x, y }, index) => {\n    // For the very first point, we have to Move to that area\n    if (index === 0) {\n      return `M ${x},${y} `\n    }\n\n    // For all subsequent points, we can just draw a line to it.\n    return `${acc} L ${x},${y}`\n  }, '')\n/**\n * Given progress between 0 and 100, figure out the Y position, relative\n * to the X axis (from 1 to -1)\n */\nexport const getPositionAtPointRelativeToAxis = (\n  shape,\n  frequency,\n  amplitude,\n  progress\n) => {\n  switch (shape) {\n    case 'sine': {\n      // Each sine cycle is 2Pi long, in trigonometry terms.\n      // The frequency determines how many cycles are in the available space.\n      const cycleLength = Math.PI * 2\n      const totalLength = cycleLength * frequency\n\n      // the progress is through the given cycle, but we may be rendering\n      // multiple cycles.\n      const progressThroughDrawableArea = progress * (1 / frequency)\n\n      // Right now, `progress` ranges from 0 to 100.\n      // Normalize this value to fit between 0 and `totalLength`.\n      // Just cross-multiplying to get the normalized value:\n      //\n      // progress         positionInRads\n      // --------  =      --------------\n      //   100             totalLength\n      //\n      // prettier-ignore\n      const positionInRads = (progressThroughDrawableArea * totalLength) / 100\n\n      // Now we can simply take the sin of the rad position to get a value,\n      // from -1 to 1. We multiply by amplitude (a value between 0 and 1) to\n      // make sure the waveform isn't more powerful than desired.\n      return Math.sin(positionInRads) * amplitude\n    }\n\n    case 'square': {\n      // Square waves are easy; the value is either `amplitude` or `-amplitude`.\n      // Figure out how far we are through the current iteration, since the\n      // drawable wave might have multiple iterations if frequency > 1Hz.\n      const progressThroughIteration = progress % 100\n\n      return progressThroughIteration < 50 ? amplitude : -amplitude\n    }\n\n    case 'sawtooth': {\n      // Each sawtooth iteration simply ranges from `-amplitude` to `amplitude`\n      // in a linear way.\n\n      const progressThroughIteration = progress % 100\n\n      // Normally, this would be a simple cross-multiplication to normalize\n      // between min and max, but our min is a negative number. Start by\n      // adding that amount so that it ranges from `0 - 2*amplitude`\n      const adjustedMax = amplitude * 2\n\n      return progressThroughIteration * adjustedMax / 100 - amplitude\n    }\n\n    case 'triangle': {\n      // This waveform might include multiple iterations, if frequency > 1Hz.\n      // This is an easy thing to solve, though; make it cyclical so that we're\n      // only looking at values from 0 to 99.\n      const progressThroughIteration = progress % 100\n\n      // Each triangle iteration has 4 quadrants of equal size:\n      // - the initial ramp up from 0 to 1\n      // - the ramp down from 1 to 0,\n      // - another from 0 to -1\n      // - the final ramp back up from -1 to 0.\n      //\n      //  Q1 | Q2 |    |\n      //    /|\\   |    |\n      //  /  |  \\ |    |\n      //  ---|---\\|--- |-----/--------------------------------\n      //     |    | \\  |   /\n      //     |    |  \\ | /\n      //     |    | Q3 | Q4\n      //\n      // Our `progressThroughIteration` is a value from 0 to 99, so we can\n      // figure out which quadrant it's in by dividing this number by 4.\n      //\n      // (Adding 1 so that it ranges from 1-4 instead of 0.3. So that, for\n      // example, 'second quadrant' is unambiguous.)\n      const quadrant = Math.floor(progressThroughIteration / 25) + 1\n\n      const progressThroughQuadrant = progress % 25\n\n      switch (quadrant) {\n        case 1: {\n          // Quadrant 1 is easy, since it ranges from 0 to 1.\n          // To get the value from 0 to 1, just divide progress by the\n          // quadrant max (25). Then, to get the amplitude, multiply by the\n          // wave's actual amplitude.\n          //\n          // To understand the `* amplitude` bit, remember that the wave's\n          // amplitude ranges from 0 to 1.\n          // If the wave is at max loudness, this value wouldn't be necessary\n          // (since `* 1` can always be omitted).\n          // If the wave is at half amplitude, though, our triangle's peak\n          // should be halfway up from the X-axis. So we multiply by 0.5.\n          return progressThroughQuadrant / 25 * amplitude\n        }\n\n        case 2: {\n          // Quadrant 2 is similar to quadrant 1, but reversed. Going from 1-0.\n          // To solve this, we can simply subtract the value from our max\n          // amplitude.\n          // Again, if we're at max amplitude, this would just be `1 - stuff`.\n          // Since we want to \"invert\" it vertically:\n          //\n          // Value  |  Inverted value\n          // 1      |  0\n          // 0.25   |  0.75\n          // 0.5    |  0.5\n          //\n          // See how you can \"invert\" each value by subtracting it from 1?\n          //\n          // But yeah, because our max amplitude can be less than 1, we have\n          // to use `amplitude` instead of `1`.\n          return amplitude - progressThroughQuadrant / 25 * amplitude\n        }\n\n        case 3: {\n          // Our third quadrant ranges from 0 to -1.\n          // This is getting more complicated, but it's really just building on\n          // the previous 2 quadrants.\n          //\n          // Quadrant 3 is identical to quadrant 2 except that it's lower.\n          // If amplitude is 1, you could think of quadrant 2 as being 1 lower\n          // than quadrant 3.\n          //\n          // By subtracting our max amplitude from the end of the Q2 formula,\n          // we lower it accordingly.\n          return (\n            amplitude - progressThroughQuadrant / 25 * amplitude - amplitude\n          )\n        }\n\n        case 4: {\n          // Finally, our final quadrant ranges from -1 to 0.\n          // Similar to how Q3 was just Q2 minus amplitude, Q4 is really just\n          // Q1 minus amplitude.\n          //\n          // This make sense when you think about it. Q3 is just Q2 but lower.\n          // Similarly, Q4 is just Q1 but lower.\n          return progressThroughQuadrant / 25 * amplitude - amplitude\n        }\n\n        default: {\n          // Should be impossible\n          throw new Error('Unrecognized quadrant!')\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unrecognized waveform shape supplied: ' + shape)\n  }\n}\n\nexport const translateAxisRelativeYValue = (\n  // a value from -1 to 1 (relative to the axis)\n  yValue,\n  // The height in pixels of our waveform drawing\n  height\n) => {\n  // Invert the y value. This is so that negative values are below the line,\n  // while positive ones are above it.\n  yValue *= -1\n\n  // Start by changing the range of the yValue:\n  // -1...1 -> 0...2\n  const incrementedYValue = yValue + 1\n\n  // Now we can just cross-multiply!\n  //     Y              X\n  //  ------    =    ------\n  //     2           height\n  //\n  // prettier-ignore\n  return (incrementedYValue * height) / 2\n}\n\nexport const getInterceptPosition = (\n  shape,\n  height,\n  frequency,\n  amplitude,\n  progress\n) => {\n  const relativePosition = getPositionAtPointRelativeToAxis(\n    shape,\n    frequency,\n    amplitude,\n    progress\n  )\n\n  return translateAxisRelativeYValue(relativePosition, height)\n}\n\nexport const applyWaveformAddition = (\n  mainWave,\n  appliedWaves,\n  // ratio is the \"effect\" of the applied wave on the main wave, from 0-1.\n  ratio\n) => {\n  if (ratio === 0) {\n    // At 0, it has no effect. We can just return the main wave as-is.\n    return mainWave\n  }\n\n  // For everything in-between, the applied wave adjusts the main wave by the\n  // amount specified.\n  return mainWave.map((point, index) => {\n    const appliedWavesAtPoint = sum(appliedWaves.map(wave => wave[index].y))\n\n    const mainValue = point.y * (1 - ratio)\n    const appliedValue = appliedWavesAtPoint * ratio\n\n    return {\n      x: point.x,\n      y: mainValue + appliedValue\n    }\n  })\n}\n\nexport const convertProgressToCycle = progress => (progress * 100) % 100\n\nexport const getHarmonicsForWave = ({\n  harmonicsForShape = 'sine',\n  baseFrequency,\n  baseAmplitude,\n  maxNumberToGenerate,\n  ...delegated\n}) => {\n  if (maxNumberToGenerate === 0) {\n    return []\n  }\n\n  switch (harmonicsForShape) {\n    // Sine waves have no harmonics\n    case 'sine':\n      return []\n\n    case 'sawtooth': {\n      return range(1, maxNumberToGenerate).map(i => {\n        // the first index would be our main wave; we're only interested in the\n        // harmonics.\n        const harmonicIndex = i + 1\n\n        const frequency = baseFrequency * harmonicIndex\n        const amplitude = baseAmplitude / harmonicIndex\n\n        return { shape: 'sine', frequency, amplitude, ...delegated }\n      })\n    }\n\n    case 'square': {\n      return range(1, maxNumberToGenerate).map(i => {\n        // Our index will be simple increments (1,2,3,4...)\n        // We're only interested in ODD harmonics for square waves, though\n        // (3, 5, 7, 9...)\n        //\n        // We want to do the following conversion:\n        //\n        // Index | Harmonic\n        //   1   |    3\n        //   2   |    5\n        //   3   |    7\n        //   4   |    9\n        //\n        // Looking at the numbers, a simple formula presents itself:\n        const harmonicIndex = i * 2 + 1\n\n        const frequency = baseFrequency * harmonicIndex\n        const amplitude = baseAmplitude / harmonicIndex\n\n        return { shape: 'sine', frequency, amplitude, ...delegated }\n      })\n    }\n\n    case 'triangle': {\n      // Triangles are similar to squares - they feature odd harmonics at\n      // ever-increasing amplitudes - but with one wrinkle: the phase is\n      // inverted for every second harmonic.\n      return range(1, maxNumberToGenerate).map(i => {\n        const harmonicIndex = i * 2 + 1\n\n        // Triangles alternate phases.\n        // To understand this, first we need to understand that these two things\n        // are equivalent:\n        //\n        // - cut the offset of the waveform by π (AKA 50%)\n        // - Multiplying the amplitude by -1\n        //\n        // The reason for this makes sense if you imagine both scenarios.\n        // A periodic waveform like the triangle can be thought of in 2 \"halves\"\n        // the first half is a positive triangle, the second half is negative.\n        //\n        //   First\n        //    /\\ |\n        //  /   \\|\n        //  -----|------/-\n        //       |\\   /\n        //       | \\/\n        //       |Second\n        //\n        // When we rotate the offset by 50%, we invert it:\n        //\n        //           Second\n        //             /\\\n        //           /   \\\n        //  \\------/------\\\n        //   \\   /\n        //    \\/\n        //  First\n        //\n        // Similarly, if we multiply every point's amplitude by -1, we achieve\n        // the exact same effect, through a different mechanism; instead of\n        // pulling the waveform forward by 50%, we rotate it across a 3D axis\n        // (imagine flipping a sign away from you to be upside down).\n        //\n        // So yeah, for triangles to work, we need to invert every second\n        // wave that we add.\n        const isOddHarmonic = i % 2 !== 0\n        const amplitudePhaseMultiplier = isOddHarmonic ? -1 : 1\n\n        const frequency = baseFrequency * harmonicIndex\n        const amplitude =\n          baseAmplitude / harmonicIndex ** 2 * amplitudePhaseMultiplier\n\n        return { shape: 'sine', frequency, amplitude, ...delegated }\n      })\n    }\n\n    default:\n      return []\n  }\n}\n\nexport const getWaveforms = ({\n  type,\n  harmonicsForShape,\n  phase = 0,\n  baseFrequency,\n  baseAmplitude,\n  numOfHarmonics\n}) => {\n  switch (type) {\n    case 'phase': {\n      // Our phase ranges from 0 to 360, but we need to convert that to our\n      // 0-100 offset for the waves. Additionally, we want the value to go\n      // from 100-o, so that the phase moves to the right instead of the left.\n      const offset = 100 - phase * 100 / 360\n\n      return [\n        {\n          shape: 'sine',\n          frequency: baseFrequency,\n          amplitude: baseAmplitude * 0.5,\n          offset,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.secondary[500], 0.6)\n        },\n        {\n          shape: 'sine',\n          frequency: baseFrequency,\n          amplitude: baseAmplitude * 0.5,\n          offset: 0,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.primary[500], 0.6)\n        }\n      ]\n    }\n\n    case 'chord': {\n      const sharedProperties = {\n        shape: 'sine',\n        amplitude: 0.45,\n        offset: 0,\n        strokeWidth: 5\n      }\n\n      return [\n        {\n          ...sharedProperties,\n          frequency: baseFrequency,\n          color: convertHexToRGBA(COLORS.tertiary[500], 0.6)\n        },\n        {\n          ...sharedProperties,\n          frequency: baseFrequency * 1.25,\n          color: convertHexToRGBA(COLORS.secondary[500], 0.6)\n        },\n        {\n          ...sharedProperties,\n          frequency: baseFrequency * 1.5,\n          color: convertHexToRGBA(COLORS.primary[500], 0.6)\n        }\n      ]\n    }\n\n    case 'harmonics':\n      return [\n        ...getHarmonicsForWave({\n          harmonicsForShape,\n          baseFrequency,\n          baseAmplitude,\n          maxNumberToGenerate: numOfHarmonics,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.secondary[500], 0.6)\n        }),\n        {\n          shape: 'sine',\n          frequency: baseFrequency,\n          amplitude: baseAmplitude,\n          offset: 0,\n          strokeWidth: 5,\n          color: convertHexToRGBA(COLORS.primary[500], 0.6)\n        }\n      ]\n\n    default:\n      throw new Error('Unrecognized type for `IntroRouteWaveformAddition`')\n  }\n}\n","import React from 'react'\nimport {\n  getPointsForWaveform,\n  createSVGPathFromWaveformPoints,\n  translateAxisRelativeYValue\n} from '../helpers/waveform.helpers'\n\nimport bannerImageSource from '../images/banner.jpg'\nimport pic01Source from '../images/pic01.jpg'\n\nclass Animation extends React.Component {\n  constructor () {\n    super()\n    this.state = {\n      offset: 0\n    }\n  }\n  componentDidMount () {\n    const animate = () => {\n      this.updateProgress()\n      window.requestAnimationFrame(animate)\n    }\n    animate()\n  }\n  updateProgress () {\n    this.setState((previousState, props) => {\n      return { offset: previousState.offset + props.speed }\n    })\n  }\n  render () {\n    const props = {\n      color: 'black',\n      strokeWidth: '50px',\n      opacity: 0.5,\n      width: 200,\n      height: 1000,\n      frequency: 0.2,\n      amplitude: 0.75,\n      shape: 'sine'\n    }\n    const {\n      color,\n      strokeWidth,\n      strokeLinecap,\n      width,\n      height,\n      shape,\n      frequency,\n      amplitude\n    } = props\n\n    const points = getPointsForWaveform({\n      shape,\n      frequency,\n      amplitude,\n      width,\n      offset: this.state.offset\n    }).map(point => {\n      const relativeY = translateAxisRelativeYValue(point.y, height)\n      return {\n        x: point.x,\n        y: relativeY\n      }\n    })\n\n    const svgPath = createSVGPathFromWaveformPoints(points, height)\n\n    const cx = width / 2 + this.state.offset\n    const cy = height / 2\n    const r = height / 2\n    // return (\n    //   <svg width={width} height={height} style={{ overflow: 'visible' }}>\n    //     <defs>\n    //       <clipPath id='circle-clip'>\n    //         <circle cx={cx} cy={cy} r={r} />\n    //       </clipPath>\n    //     </defs>\n    //     <circle cx={cx} cy={cy} r={r} fill='none' stroke='black' />\n    //     <path\n    //       id='waveform'\n    //       d={svgPath}\n    //       stroke={color}\n    //       strokeWidth={strokeWidth}\n    //       strokeLinecap={strokeLinecap}\n    //       fill='none'\n    //       clipPath='url(#circle-clip)'\n    //     />\n    //   </svg>\n    // )\n    return (\n      <svg width={0} height={0} style={{ overflow: 'visible' }}>\n        <defs>\n          <clipPath id='waveform'>\n            <path\n              d={svgPath}\n              stroke={color}\n              strokeWidth={strokeWidth}\n              strokeLinecap={strokeLinecap}\n              fill='none'\n              clipPath='url(#circle-clip)'\n            />\n          </clipPath>\n        </defs>\n        <path\n          d={svgPath}\n          stroke={color}\n          strokeWidth={strokeWidth}\n          strokeLinecap={strokeLinecap}\n          fill='none'\n          clipPath='url(#circle-clip)'\n        />\n      </svg>\n    )\n  }\n}\n\nAnimation.defaultProps = {\n  speed: 0.1\n}\n\nexport default () => {\n  return (\n    <div>\n      <Animation />\n      <img id='hero' src={bannerImageSource} />\n    </div>\n  )\n}\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","module.exports = __webpack_public_path__ + \"static/pic01-f3e58a3fac18a43921daf41ca5ac818c.jpg\";","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","module.exports = __webpack_public_path__ + \"static/banner-1707ad6f2581cd8d0ce12c2dc884153b.jpg\";","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n"],"sourceRoot":""}